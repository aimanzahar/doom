<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Doom Mini</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Oxanium:wght@400;600&display=swap");

    :root {
      --bg: #0a0d1a;
      --bg-2: #0f172a;
      --accent: #f57328;
      --accent-2: #20e3b2;
      --panel: rgba(255, 255, 255, 0.05);
      --text: #e9ecf5;
      --muted: #9fb0c7;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Oxanium", "Share Tech Mono", system-ui, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(32, 227, 178, 0.2), transparent 30%),
        radial-gradient(circle at 80% 0%, rgba(245, 115, 40, 0.2), transparent 30%),
        linear-gradient(135deg, var(--bg), #070a15 40%, var(--bg-2));
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .frame {
      width: min(1100px, 100%);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      box-shadow: 0 25px 70px rgba(0, 0, 0, 0.55), 0 0 0 1px rgba(255, 255, 255, 0.04) inset;
      backdrop-filter: blur(8px);
      overflow: hidden;
    }

    header {
      padding: 18px 20px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(90deg, rgba(32, 227, 178, 0.08), rgba(245, 115, 40, 0.08));
      gap: 12px;
    }

    .title {
      font-size: 18px;
      letter-spacing: 0.6px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 16px rgba(32, 227, 178, 0.6);
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .keys {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .key {
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.05);
      font-family: "Share Tech Mono", monospace;
      letter-spacing: 0.4px;
    }

    .board {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #050712;
      touch-action: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 18px;
      font-family: "Share Tech Mono", monospace;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
    }

    .stats {
      display: flex;
      gap: 16px;
      font-size: 14px;
      flex-wrap: wrap;
    }

    .pill {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      padding: 6px 12px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 16px;
      height: 16px;
      margin-left: -8px;
      margin-top: -8px;
      pointer-events: none;
      display: grid;
      place-items: center;
    }

    .crosshair span {
      display: block;
      width: 2px;
      height: 2px;
      background: var(--text);
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.7);
      border-radius: 50%;
    }

    .footer {
      padding: 12px 18px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      gap: 12px;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="frame">
    <header>
      <div class="title"><span class="dot"></span> Neon Doom Mini</div>
      <div class="hint">
        Controls:
        <span class="keys">
          <span class="key">WASD</span>
          <span class="key">← →</span>
          <span class="key">SPACE / Tap</span>
          <span class="key">Drag</span>
          <span class="key">SHIFT</span>
        </span>
        Move / Turn / Fire / Look / Sprint
      </div>
    </header>
    <div class="board">
      <canvas id="view" width="960" height="540"></canvas>
      <div class="hud">
        <div class="stats">
          <div class="pill">Health: <span id="hp">100</span></div>
          <div class="pill">Demons: <span id="demons">0</span></div>
          <div class="pill">Ammo: <span id="ammo">∞</span></div>
        </div>
        <div class="pill" style="align-self: flex-end;">R to restart • Drag to look</div>
      </div>
      <div class="crosshair"><span></span></div>
    </div>
    <div class="footer">A tiny ray-casting experiment. Hug walls for cover, clear the demons.</div>
  </div>

  <script>
    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");
    const hpEl = document.getElementById("hp");
    const demonEl = document.getElementById("demons");

    const FOV = Math.PI / 1.7; // ~105deg
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const numRays = Math.floor(WIDTH / 1.5);
    const columnWidth = WIDTH / numRays;
    const depthBuffer = new Array(numRays);

    // Simple maze layout
    const map = [
      "111111111111",
      "1..1....1..1",
      "1..1..2.1..1",
      "1......1...1",
      "1.111..1.1.1",
      "1....2...1.1",
      "1..1....1..1",
      "1..11111...1",
      "1..0.....2.1",
      "1....1.....1",
      "1..2.....0.1",
      "111111111111",
    ];
    const mapH = map.length;
    const mapW = map[0].length;

    const player = {
      x: 2.5,
      y: 2.5,
      angle: 0,
      speed: 3.2,
      health: 100,
      dead: false,
    };

    const demons = [];
    const spawnPoints = [
      { x: 9.5, y: 2.5 },
      { x: 9.2, y: 9.5 },
      { x: 2.5, y: 9.2 },
      { x: 6.5, y: 6.5 },
    ];

    const keys = {};
    let pointerActive = false;
    let pointerLastX = 0;
    const pointerSensitivity = 0.0035;
    let demonTexture = null;
    let muzzle = 0;
    let hurtFlash = 0;
    let gameOver = false;
    let win = false;
    let shotCooldown = 0;
    let time = 0;

    function resetGame() {
      player.x = 2.5;
      player.y = 2.5;
      player.angle = 0;
      player.health = 100;
      player.dead = false;
      gameOver = false;
      win = false;
      demons.length = 0;
      spawnDemons();
    }

    function spawnDemons() {
      spawnPoints.forEach((p) => {
        demons.push({
          x: p.x + (Math.random() - 0.5) * 0.4,
          y: p.y + (Math.random() - 0.5) * 0.4,
          health: 3,
          hitTimer: 0,
        });
      });
      demonEl.textContent = demons.length;
    }

    function createDemonTexture() {
      const size = 64;
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const g = c.getContext("2d");

      const body = g.createRadialGradient(size * 0.5, size * 0.5, size * 0.12, size * 0.5, size * 0.5, size * 0.48);
      body.addColorStop(0, "#a0182a");
      body.addColorStop(1, "#2b0610");
      g.fillStyle = body;
      g.beginPath();
      g.ellipse(size * 0.5, size * 0.56, size * 0.34, size * 0.44, 0, 0, Math.PI * 2);
      g.fill();

      // Horns (darker, pointier)
      g.fillStyle = "#7a1a0f";
      g.beginPath();
      g.moveTo(size * 0.35, size * 0.26);
      g.lineTo(size * 0.43, size * 0.02);
      g.lineTo(size * 0.48, size * 0.28);
      g.closePath();
      g.fill();
      g.beginPath();
      g.moveTo(size * 0.52, size * 0.28);
      g.lineTo(size * 0.57, size * 0.02);
      g.lineTo(size * 0.65, size * 0.26);
      g.closePath();
      g.fill();

      // Angry brows
      g.fillStyle = "#0a0102";
      g.beginPath();
      g.moveTo(size * 0.30, size * 0.43);
      g.lineTo(size * 0.46, size * 0.38);
      g.lineTo(size * 0.47, size * 0.44);
      g.lineTo(size * 0.31, size * 0.48);
      g.closePath();
      g.fill();
      g.beginPath();
      g.moveTo(size * 0.70, size * 0.43);
      g.lineTo(size * 0.54, size * 0.38);
      g.lineTo(size * 0.53, size * 0.44);
      g.lineTo(size * 0.69, size * 0.48);
      g.closePath();
      g.fill();

      // Eyes (slanted, glowing)
      g.fillStyle = "#ffddbb";
      g.beginPath();
      g.moveTo(size * 0.32, size * 0.45);
      g.lineTo(size * 0.45, size * 0.41);
      g.lineTo(size * 0.45, size * 0.48);
      g.lineTo(size * 0.32, size * 0.52);
      g.closePath();
      g.fill();
      g.beginPath();
      g.moveTo(size * 0.68, size * 0.45);
      g.lineTo(size * 0.55, size * 0.41);
      g.lineTo(size * 0.55, size * 0.48);
      g.lineTo(size * 0.68, size * 0.52);
      g.closePath();
      g.fill();

      g.fillStyle = "#1b0202";
      g.fillRect(size * 0.36, size * 0.46, size * 0.06, size * 0.05);
      g.fillRect(size * 0.58, size * 0.46, size * 0.06, size * 0.05);

      // Mouth with teeth
      g.fillStyle = "#1a0406";
      g.fillRect(size * 0.30, size * 0.60, size * 0.40, size * 0.12);
      g.fillStyle = "#f5f1e8";
      const teeth = 6;
      for (let i = 0; i < teeth; i++) {
        const tX = size * 0.30 + (i / teeth) * size * 0.40;
        g.beginPath();
        g.moveTo(tX, size * 0.60);
        g.lineTo(tX + size * 0.04, size * 0.60);
        g.lineTo(tX + size * 0.02, size * 0.68);
        g.closePath();
        g.fill();
      }

      // Subtle highlight
      const shine = g.createLinearGradient(0, 0, size, size);
      shine.addColorStop(0, "rgba(255,255,255,0.14)");
      shine.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = shine;
      g.fillRect(0, 0, size, size);

      return c;
    }

    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === " " || e.code === "Space") {
        e.preventDefault();
      }
      if (e.key.toLowerCase() === "r") resetGame();
    });

    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Pointer look (mouse/touch drag) + tap to shoot
    canvas.addEventListener("pointerdown", (e) => {
      pointerActive = true;
      pointerLastX = e.clientX;
      canvas.setPointerCapture(e.pointerId);
      tryShoot();
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointerActive) return;
      const dx = e.clientX - pointerLastX;
      pointerLastX = e.clientX;
      player.angle = normalizeAngle(player.angle + dx * pointerSensitivity);
    });

    canvas.addEventListener("pointerup", (e) => {
      pointerActive = false;
      canvas.releasePointerCapture(e.pointerId);
    });

    canvas.addEventListener("pointercancel", () => {
      pointerActive = false;
    });

    function normalizeAngle(a) {
      while (a < -Math.PI) a += Math.PI * 2;
      while (a > Math.PI) a -= Math.PI * 2;
      return a;
    }

    function cell(x, y) {
      if (x < 0 || y < 0 || x >= mapW || y >= mapH) return "1";
      return map[y][x];
    }

    function isWall(x, y) {
      return cell(x, y) === "1";
    }

    function castRay(angle) {
      const px = player.x;
      const py = player.y;
      const sin = Math.sin(angle) || 0.0001;
      const cos = Math.cos(angle) || 0.0001;

      let mapX = Math.floor(px);
      let mapY = Math.floor(py);

      const deltaDistX = Math.abs(1 / cos);
      const deltaDistY = Math.abs(1 / sin);

      let stepX, stepY, sideDistX, sideDistY;
      if (cos < 0) {
        stepX = -1;
        sideDistX = (px - mapX) * deltaDistX;
      } else {
        stepX = 1;
        sideDistX = (mapX + 1 - px) * deltaDistX;
      }
      if (sin < 0) {
        stepY = -1;
        sideDistY = (py - mapY) * deltaDistY;
      } else {
        stepY = 1;
        sideDistY = (mapY + 1 - py) * deltaDistY;
      }

      let side = 0;
      let hit = false;
      let tile = "0";
      let guard = 0;

      while (!hit && guard++ < 64) {
        if (sideDistX < sideDistY) {
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        } else {
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        tile = cell(mapX, mapY);
        if (tile === "1") hit = true;
      }

      const distance =
        side === 0 ? sideDistX - deltaDistX : sideDistY - deltaDistY;

      return { distance, side, tile };
    }

    function movePlayer(dt) {
      if (gameOver) return;
      if (win) return;
      const turnSpeed = 1.8;
      if (keys["arrowleft"] || keys["q"]) player.angle -= turnSpeed * dt;
      if (keys["arrowright"] || keys["e"]) player.angle += turnSpeed * dt;
      player.angle = normalizeAngle(player.angle);

      const sprint = keys["shift"] ? 1.5 : 1;
      const moveSpeed = player.speed * sprint;

      let moveX = 0;
      let moveY = 0;
      if (keys["w"] || keys["arrowup"]) {
        moveX += Math.cos(player.angle);
        moveY += Math.sin(player.angle);
      }
      if (keys["s"] || keys["arrowdown"]) {
        moveX -= Math.cos(player.angle);
        moveY -= Math.sin(player.angle);
      }
      if (keys["a"]) {
        moveX += Math.cos(player.angle - Math.PI / 2);
        moveY += Math.sin(player.angle - Math.PI / 2);
      }
      if (keys["d"]) {
        moveX += Math.cos(player.angle + Math.PI / 2);
        moveY += Math.sin(player.angle + Math.PI / 2);
      }

      const len = Math.hypot(moveX, moveY);
      if (len > 0) {
        moveX = (moveX / len) * moveSpeed * dt;
        moveY = (moveY / len) * moveSpeed * dt;
        const newX = player.x + moveX;
        const newY = player.y + moveY;
        if (!isWall(Math.floor(newX), Math.floor(player.y))) player.x = newX;
        if (!isWall(Math.floor(player.x), Math.floor(newY))) player.y = newY;
      }
    }

    function updateDemons(dt) {
      if (win) return;
      const attackRange = 0.65;
      demons.forEach((d) => {
        if (d.health <= 0) return;
        const dx = player.x - d.x;
        const dy = player.y - d.y;
        const dist = Math.hypot(dx, dy);
        const dirAngle = Math.atan2(dy, dx);
        const step = Math.max(1.2, 2.4 - dist * 0.2);

        // Move toward player but avoid walls
        const proposedX = d.x + Math.cos(dirAngle) * step * dt;
        const proposedY = d.y + Math.sin(dirAngle) * step * dt;
        if (!isWall(Math.floor(proposedX), Math.floor(d.y))) d.x = proposedX;
        if (!isWall(Math.floor(d.x), Math.floor(proposedY))) d.y = proposedY;

        if (dist < attackRange && !gameOver) {
          hurtFlash = 0.3;
          player.health = Math.max(0, player.health - 10 * dt);
          if (player.health <= 0) {
            gameOver = true;
            player.dead = true;
          }
        }

        if (d.hitTimer > 0) d.hitTimer -= dt;
      });
    }

    function tryShoot() {
      if (shotCooldown > 0 || gameOver) return;
      muzzle = 0.12;
      shotCooldown = 0.25;

      let best = null;
      let bestDist = Infinity;
      demons.forEach((d) => {
        if (d.health <= 0) return;
        const dx = d.x - player.x;
        const dy = d.y - player.y;
        const dist = Math.hypot(dx, dy);
        const ang = Math.atan2(dy, dx);
        const diff = Math.abs(normalizeAngle(ang - player.angle));
        if (diff < 0.2 && dist < bestDist && dist < 9) {
          best = d;
          bestDist = dist;
        }
      });

      if (best) {
        best.health -= 1;
        best.hitTimer = 0.2;
        if (best.health <= 0) {
          const alive = demons.filter((d) => d.health > 0).length;
          demonEl.textContent = alive;
          if (alive === 0) win = true;
        }
      }
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        tryShoot();
      }
    });

    function drawBackground() {
      const sky = ctx.createLinearGradient(0, 0, 0, HEIGHT / 2);
      sky.addColorStop(0, "#161d33");
      sky.addColorStop(1, "#0c1224");
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, WIDTH, HEIGHT / 2);

      const floor = ctx.createLinearGradient(0, HEIGHT / 2, 0, HEIGHT);
      floor.addColorStop(0, "#090d18");
      floor.addColorStop(1, "#05070f");
      ctx.fillStyle = floor;
      ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);
    }

    function drawWalls() {
      for (let i = 0; i < numRays; i++) {
        const rayAngle = player.angle - FOV / 2 + (i / numRays) * FOV;
        const { distance, side } = castRay(rayAngle);
        depthBuffer[i] = distance;

        const lineHeight = Math.min(HEIGHT, (HEIGHT * 0.9) / distance);
        const start = HEIGHT / 2 - lineHeight / 2;

        const fog = Math.max(0.15, 1 - distance / 12);
        const base = side ? "255,120,80" : "255,185,120";
        ctx.fillStyle = `rgba(${base},${fog})`;
        ctx.fillRect(i * columnWidth, start, columnWidth + 1, lineHeight);

        // Thin neon highlight for spice
        ctx.fillStyle = `rgba(32,227,178,${Math.max(0, fog - 0.3)})`;
        ctx.fillRect(i * columnWidth, start + lineHeight - 2, columnWidth + 1, 1);
      }
    }

    function drawDemons() {
      const sprites = demons
        .filter((d) => d.health > 0)
        .map((d) => {
          const dx = d.x - player.x;
          const dy = d.y - player.y;
          const dist = Math.hypot(dx, dy);
          const angleTo = Math.atan2(dy, dx);
          const diff = normalizeAngle(angleTo - player.angle);
          return { ref: d, dist, diff };
        })
        .filter((s) => Math.abs(s.diff) < FOV / 1.6)
        .sort((a, b) => b.dist - a.dist); // Draw far to near

      sprites.forEach(({ ref, dist, diff }) => {
        const size = Math.min(HEIGHT, (HEIGHT * 0.8) / dist);
        const screenX = WIDTH / 2 + (diff / (FOV / 2)) * (WIDTH / 2);
        const x = screenX - size / 2;
        const y = HEIGHT / 2 - size * 0.6;

        const columnIndex = Math.floor(Math.max(0, Math.min(numRays - 1, screenX / columnWidth)));
        if (depthBuffer[columnIndex] < dist - 0.1) return; // Hidden behind wall

        const flicker = 0.3 + Math.random() * 0.2;
        const alpha = Math.max(0.25, 1 - dist / 10 + flicker * 0.1);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.drawImage(demonTexture, x, y, size, size);
        if (ref.hitTimer > 0) {
          ctx.globalAlpha = Math.min(0.8, ref.hitTimer * 2);
          ctx.fillStyle = "rgba(255,80,80,0.6)";
          ctx.fillRect(x, y, size, size);
        }
        ctx.restore();
      });
    }

    function drawMiniMap() {
      const scale = 12;
      const mapSize = 140;
      const offsetX = 14;
      const offsetY = 14;

      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(offsetX - 6, offsetY - 6, mapSize, mapSize);

      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          if (map[y][x] === "1") {
            ctx.fillStyle = "rgba(255,255,255,0.18)";
            ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale - 1, scale - 1);
          }
          if (map[y][x] === "2") {
            ctx.fillStyle = "rgba(32,227,178,0.4)";
            ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale - 1, scale - 1);
          }
        }
      }

      ctx.fillStyle = "#f57328";
      ctx.beginPath();
      ctx.arc(offsetX + player.x * scale, offsetY + player.y * scale, 4, 0, Math.PI * 2);
      ctx.fill();

      const fx = Math.cos(player.angle) * 8;
      const fy = Math.sin(player.angle) * 8;
      ctx.strokeStyle = "#f57328";
      ctx.beginPath();
      ctx.moveTo(offsetX + player.x * scale, offsetY + player.y * scale);
      ctx.lineTo(offsetX + player.x * scale + fx, offsetY + player.y * scale + fy);
      ctx.stroke();

      ctx.restore();
    }

    function drawHUD() {
      hpEl.textContent = player.health.toFixed(0);
      const alive = demons.filter((d) => d.health > 0).length;
      demonEl.textContent = alive;

      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = "#f57328";
        ctx.font = "32px 'Oxanium', sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Mission failed", WIDTH / 2, HEIGHT / 2 - 10);
        ctx.fillStyle = "#9fb0c7";
        ctx.font = "18px 'Share Tech Mono', monospace";
        ctx.fillText("Press R to restart", WIDTH / 2, HEIGHT / 2 + 22);
      } else if (win) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = "#20e3b2";
        ctx.font = "32px 'Oxanium', sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Sector cleared!", WIDTH / 2, HEIGHT / 2 - 10);
        ctx.fillStyle = "#9fb0c7";
        ctx.font = "18px 'Share Tech Mono', monospace";
        ctx.fillText("Press R to run it back", WIDTH / 2, HEIGHT / 2 + 22);
      }

      if (muzzle > 0) {
        ctx.fillStyle = "rgba(255,245,200,0.25)";
        ctx.fillRect(0, HEIGHT - 120, WIDTH, 120);
      }
      if (hurtFlash > 0) {
        ctx.fillStyle = `rgba(245,80,80,${hurtFlash})`;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
      }
    }

    function draw() {
      drawBackground();
      drawWalls();
      drawDemons();
      drawMiniMap();
      drawHUD();

      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(WIDTH / 2 - 10, HEIGHT / 2);
      ctx.lineTo(WIDTH / 2 + 10, HEIGHT / 2);
      ctx.moveTo(WIDTH / 2, HEIGHT / 2 - 10);
      ctx.lineTo(WIDTH / 2, HEIGHT / 2 + 10);
      ctx.stroke();
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      time += dt;

      movePlayer(dt);
      updateDemons(dt);

      if (shotCooldown > 0) shotCooldown -= dt;
      if (muzzle > 0) muzzle -= dt;
      if (hurtFlash > 0) hurtFlash -= dt;

      draw();
      requestAnimationFrame(loop);
    }

    resetGame();
    demonTexture = createDemonTexture();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
